<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Master v3.0 - –ü–∏–∫—Å–µ–ª—å–Ω—ã–π –ú–∞—Å—Ç–µ—Ä</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Yandex Games uchun moslashtirilgan CSS */
        :root {
            --bg-primary: #f9fafb;
            --bg-secondary: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
        }

        [data-theme="dark"] {
            --bg-primary: #1f2937;
            --bg-secondary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --border-color: #4b5563;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
            overflow-x: hidden;
        }

        .card {
            background-color: var(--bg-secondary);
            transition: all 0.3s ease;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .cell {
            transition: all 0.1s ease;
            cursor: pointer;
            border-width: 2px;
            border-color: #9ca3af;
            border-radius: 0.25rem;
        }

        .cell:hover {
            transform: scale(1.1);
            border-color: #3b82f6 !important;
        }

        .cell:active {
            transform: scale(0.95);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .animate-pulse-custom {
            animation: pulse 2s infinite;
        }

        /* Volume slider styling */
        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 5px;
            background: #d1d5db;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }

        /* Yandex Games uchun maxsus sozlamalar */
        #app {
            width: 100%;
            min-height: 100vh;
        }

        .game-container {
            min-height: 100vh;
            padding: 1rem;
        }

        /* Grid uchun maxsus sozlamalar */
        .grid-container {
            display: inline-grid;
            gap: 2px;
            background-color: #d1d5db;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
    </style>
</head>

<body>
    <div id="app"></div>

    <script>
        // Constants
        const WHITE_COLOR = '#FFFFFF';
        const GAME_COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
            '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
            '#F8B195', '#C06C84', '#6C5B7B', '#355C7D',
            '#E74C3C', '#3498DB', '#2ECC71', '#F39C12',
            '#9B59B6', '#1ABC9C', '#E67E22', '#95A5A6'
        ];

        // Game State
        let gameState = {
            currentStage: 1,
            totalStages: 400,
            grid: [],
            targetGrid: [],
            selectedColor: GAME_COLORS[0],
            moves: 0,
            score: 0,
            completed: false,
            showTarget: true,
            soundEnabled: true,
            musicEnabled: true,
            darkMode: false,
            musicVolume: 20,
            soundVolume: 50,
            audioContext: null,
            backgroundMusic: null
        };

        // Game Logic Functions
        const getGridSize = (level) => Math.min(6 + level, 20);

        const getColorCount = (level) => Math.min(2 + Math.floor(level / 2), 8);

        const getCurrentLevel = (stage) => Math.floor((stage - 1) / 5) + 1;

        const getStageInLevel = (stage) => ((stage - 1) % 5) + 1;

        // Har bir stage uchun unique seed yaratish
        const getStagesSeed = (stage) => stage * 12345 + stage * stage * 67890;

        // Pseudorandom number generator (har stage uchun unique)
        const seededRandom = (seed, min = 0, max = 1) => {
            const x = Math.sin(seed) * 10000;
            const random = x - Math.floor(x);
            return min + random * (max - min);
        };

        // 30+ turli xil pattern generatori
        const generatePattern = (size, stage, level) => {
            const pattern = Array(size).fill(null).map(() => Array(size).fill(0));
            const colorCount = getColorCount(level);
            const seed = getStagesSeed(stage);
            const centerX = Math.floor(size / 2);
            const centerY = Math.floor(size / 2);

            // 30 xil pattern turi
            const patternType = stage % 30;

            switch (patternType) {
                case 0: // Spiral pattern
                    let x = centerX, y = centerY;
                    let dx = 0, dy = -1;
                    let steps = 1;
                    let stepCount = 0;
                    let colorIndex = 1;

                    for (let i = 0; i < size * size; i++) {
                        if (x >= 0 && x < size && y >= 0 && y < size) {
                            pattern[y][x] = colorIndex;
                            colorIndex = (colorIndex % colorCount) + 1;
                        }

                        if (stepCount === steps) {
                            stepCount = 0;
                            const temp = dx;
                            dx = -dy;
                            dy = temp;
                            if (dy === 0) steps++;
                        }

                        x += dx;
                        y += dy;
                        stepCount++;
                    }
                    break;

                case 1: // Yurak shakli (yaxshilangan)
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const x = (j - centerX) / (size / 6);
                            const y = (i - centerY) / (size / 6);
                            const heart = Math.pow(x * x + y * y - 1, 3) - x * x * y * y * y;
                            if (heart < 0) {
                                const dist = Math.sqrt(Math.pow(i - centerY, 2) + Math.pow(j - centerX, 2));
                                pattern[i][j] = (Math.floor(dist * 3) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 2: // Konsentrik doiralar
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dist = Math.sqrt(
                                Math.pow(i - centerY, 2) + Math.pow(j - centerX, 2)
                            );
                            const ring = Math.floor(dist / (size / (colorCount * 2)));
                            if (ring < colorCount) {
                                pattern[i][j] = ring + 1;
                            }
                        }
                    }
                    break;

                case 3: // Shaxmat taxtasi
                    const blockSize = Math.max(1, Math.floor(size / 6));
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const blockI = Math.floor(i / blockSize);
                            const blockJ = Math.floor(j / blockSize);
                            if ((blockI + blockJ) % 2 === 0) {
                                pattern[i][j] = ((blockI + blockJ) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 4: // Yulduz shakli
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx);
                            const radius = Math.sqrt(dx * dx + dy * dy);
                            const starRadius = (size / 3) * (1 + 0.5 * Math.sin(5 * angle));
                            if (radius < starRadius) {
                                pattern[i][j] = (Math.floor(angle * 10) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 5: // Radial gradient
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dist = Math.sqrt(
                                Math.pow(i - centerY, 2) + Math.pow(j - centerX, 2)
                            );
                            const normalized = dist / (size / 2);
                            pattern[i][j] = Math.min(Math.floor(normalized * colorCount) + 1, colorCount);
                        }
                    }
                    break;

                case 6: // Zigzag pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const wave = Math.floor(Math.abs(Math.sin(j / 3) * 5));
                            if (i % 4 === wave % 4) {
                                pattern[i][j] = (j % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 7: // Mandala pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const mandala = Math.floor(Math.abs(Math.sin(angle * 8) * dist));
                            if (mandala % 3 === 0 && dist < size / 2) {
                                pattern[i][j] = (mandala % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 8: // Diamond pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const diamondDist = Math.abs(i - centerY) + Math.abs(j - centerX);
                            if (diamondDist < size / 2) {
                                pattern[i][j] = (diamondDist % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 9: // Crosshatch pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            if ((i + j) % 4 === 0 || (i - j) % 4 === 0) {
                                pattern[i][j] = ((i * j) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 10: // Flower pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx);
                            const radius = Math.sqrt(dx * dx + dy * dy);
                            const petalRadius = (size / 4) * (1 + Math.sin(6 * angle) * 0.5);
                            if (radius < petalRadius) {
                                pattern[i][j] = (Math.floor(radius * 2) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 11: // Hexagonal pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const hexSize = Math.max(2, Math.floor(size / 8));
                            const hexI = Math.floor(i / hexSize);
                            const hexJ = Math.floor(j / hexSize);
                            const offset = hexI % 2 === 0 ? 0 : hexSize / 2;
                            if ((j - offset) % hexSize < hexSize - 1) {
                                pattern[i][j] = ((hexI + hexJ) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 12: // Wave interference pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const wave1 = Math.sin(i / 2) * 3;
                            const wave2 = Math.sin(j / 2) * 3;
                            const interference = Math.floor(Math.abs(wave1 + wave2));
                            if (interference % 2 === 0) {
                                pattern[i][j] = (interference % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 13: // Pyramid pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const level = Math.min(i, j, size - 1 - i, size - 1 - j);
                            pattern[i][j] = (level % colorCount) + 1;
                        }
                    }
                    break;

                case 14: // Sunburst pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx) + Math.PI;
                            const rayCount = 12;
                            const ray = Math.floor((angle / (2 * Math.PI)) * rayCount);
                            if (ray % 2 === 0) {
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                pattern[i][j] = (Math.floor(dist) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 15: // Celtic knot inspired
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const knotPattern = (Math.sin(i / 2) + Math.cos(j / 2)) * 3;
                            if (Math.floor(Math.abs(knotPattern)) % 2 === 0) {
                                pattern[i][j] = (Math.floor(Math.abs(knotPattern)) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 16: // Butterfly wings
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx);
                            const radius = Math.sqrt(dx * dx + dy * dy);
                            const wingShape = Math.abs(Math.cos(angle * 2)) * (size / 3);
                            if (radius < wingShape) {
                                pattern[i][j] = (Math.floor(angle * 5) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 17: // Maze-like pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const maze = (i * 7 + j * 11) % 13;
                            if (maze > 5) {
                                pattern[i][j] = (maze % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 18: // Target circles
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dist = Math.sqrt(
                                Math.pow(i - centerY, 2) + Math.pow(j - centerX, 2)
                            );
                            const ring = Math.floor(dist / 2);
                            if (ring % 2 === 0 && dist < size / 2) {
                                pattern[i][j] = (ring % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 19: // Lightning bolt
                    for (let i = 0; i < size; i++) {
                        const zigzag = centerX + Math.floor(Math.sin(i / 2) * (size / 4));
                        for (let j = Math.max(0, zigzag - 1); j <= Math.min(size - 1, zigzag + 1); j++) {
                            pattern[i][j] = ((i + j) % colorCount) + 1;
                        }
                    }
                    break;

                case 20: // Peacock feather
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const feather = Math.sin(angle * 4) * (size / 4);
                            if (dist < Math.abs(feather) + size / 6) {
                                pattern[i][j] = (Math.floor(dist + Math.abs(feather)) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 21: // Tribal pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const tribal = Math.floor((Math.sin(i / 3) + Math.cos(j / 3)) * 5);
                            if (Math.abs(tribal) > 3) {
                                pattern[i][j] = (Math.abs(tribal) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 22: // Snowflake pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = j - centerX;
                            const dy = i - centerY;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const branch = Math.floor((angle + Math.PI) / (Math.PI / 3));
                            if (Math.abs(Math.sin(branch * Math.PI / 3) * dist) < 1) {
                                pattern[i][j] = ((branch + Math.floor(dist)) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 23: // Labyrinth pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const path = (i + j) % 5;
                            if (path === 0 || path === 2) {
                                pattern[i][j] = ((i * j) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 24: // Atom structure
                    const electronRings = [size / 6, size / 4, size / 3];
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dist = Math.sqrt(
                                Math.pow(i - centerY, 2) + Math.pow(j - centerX, 2)
                            );
                            for (let r = 0; r < electronRings.length; r++) {
                                if (Math.abs(dist - electronRings[r]) < 1.5) {
                                    pattern[i][j] = (r % colorCount) + 1;
                                }
                            }
                        }
                    }
                    break;

                case 25: // Origami fold pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const fold1 = Math.abs(i - j);
                            const fold2 = Math.abs(i + j - size);
                            if (fold1 < 2 || fold2 < 2) {
                                pattern[i][j] = ((i + j) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 26: // DNA helix
                    for (let i = 0; i < size; i++) {
                        const helix1 = centerX + Math.floor(Math.sin(i / 2) * (size / 6));
                        const helix2 = centerX + Math.floor(Math.cos(i / 2) * (size / 6));

                        if (helix1 >= 0 && helix1 < size) {
                            pattern[i][helix1] = ((i % colorCount) + 1);
                        }
                        if (helix2 >= 0 && helix2 < size) {
                            pattern[i][helix2] = ((i % colorCount) + 1);
                        }
                    }
                    break;

                case 27: // Kaleidoscope
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const dx = Math.abs(j - centerX);
                            const dy = Math.abs(i - centerY);
                            const angle = Math.atan2(dy, dx);
                            const sector = Math.floor((angle / (Math.PI / 4)));
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (sector % 2 === 0 && dist < size / 2) {
                                pattern[i][j] = (Math.floor(dist) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 28: // Mosaic tiles
                    const tileSize = Math.max(2, Math.floor(size / 6));
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const tileI = Math.floor(i / tileSize);
                            const tileJ = Math.floor(j / tileSize);
                            const tilePattern = (tileI * 7 + tileJ * 13) % 3;
                            if (tilePattern > 0) {
                                pattern[i][j] = ((tileI + tileJ) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                case 29: // Circuit board pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const isHorizontalLine = i % 4 === 0;
                            const isVerticalLine = j % 4 === 0;
                            const isJunction = isHorizontalLine && isVerticalLine;

                            if (isJunction) {
                                pattern[i][j] = ((i + j) / 4 % colorCount) + 1;
                            } else if (isHorizontalLine || isVerticalLine) {
                                pattern[i][j] = ((i + j) % colorCount) + 1;
                            }
                        }
                    }
                    break;

                default:
                    // Random creative pattern
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            const randomValue = seededRandom(seed + i * size + j, 0, 1);
                            if (randomValue > 0.3) {
                                pattern[i][j] = Math.floor(randomValue * colorCount) + 1;
                            }
                        }
                    }
            }

            return pattern;
        };

        const createTargetGrid = (size, stage, level) => {
            const pattern = generatePattern(size, stage, level);
            const colorCount = getColorCount(level);
            const availableColors = GAME_COLORS.slice(0, colorCount);

            return Array(size)
                .fill(null)
                .map((_, i) =>
                    Array(size)
                        .fill(null)
                        .map((_, j) => {
                            const patternValue = pattern[i][j];
                            return patternValue === 0
                                ? WHITE_COLOR
                                : availableColors[patternValue - 1];
                        })
                );
        };

        const createEmptyGrid = (size) => {
            return Array(size)
                .fill(null)
                .map(() => Array(size).fill(WHITE_COLOR));
        };

        const checkCompletion = (playerGrid, targetGrid) => {
            return playerGrid.every((row, i) =>
                row.every((cell, j) => cell === targetGrid[i][j])
            );
        };

        const calculateScore = (moves, stage, targetGrid) => {
            const filledCells = targetGrid.flat().filter((c) => c !== WHITE_COLOR).length;
            const perfectMoves = filledCells;
            const efficiency = Math.max(0, 100 - Math.abs(moves - perfectMoves) * 2);
            const levelScore = Math.floor(efficiency + stage * 5);
            return levelScore;
        };

        // Audio Setup
        const initAudio = () => {
            try {
                gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log("Audio not supported:", e);
            }
        };

        const colorFrequencies = {
            '#FF6B6B': 523.25, '#4ECDC4': 587.33, '#45B7D1': 659.25,
            '#FFA07A': 698.46, '#98D8C8': 783.99, '#F7DC6F': 880.00,
            '#BB8FCE': 987.77, '#85C1E2': 1046.50, '#F8B195': 554.37,
            '#C06C84': 622.25, '#6C5B7B': 739.99, '#355C7D': 830.61,
            '#E74C3C': 932.33, '#3498DB': 1108.73, '#2ECC71': 1174.66,
            '#F39C12': 1318.51, '#9B59B6': 1396.91, '#1ABC9C': 1567.98,
            '#E67E22': 1760.00, '#95A5A6': 1975.53, '#FFFFFF': 440.00
        };

        // Play color sound - INGICHKA NOTA
        const playColorSound = (color) => {
            if (!gameState.audioContext || !gameState.soundEnabled) return;

            const frequency = colorFrequencies[color] || 440;
            const oscillator = gameState.audioContext.createOscillator();
            const gainNode = gameState.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(gameState.audioContext.destination);

            oscillator.type = 'sine'; // Ingichka tovush
            oscillator.frequency.value = frequency + 200; // Balandroq nota

            const volume = gameState.soundVolume / 100 * 0.08;
            gainNode.gain.value = volume;
            gainNode.gain.exponentialRampToValueAtTime(0.001, gameState.audioContext.currentTime + 0.1);

            oscillator.start();
            oscillator.stop(gameState.audioContext.currentTime + 0.1);
        };

        // Success sound - ingichka bells
        const playSuccessSound = () => {
            if (!gameState.audioContext || !gameState.soundEnabled) return;

            const notes = [1046.50, 1318.51, 1567.98, 2093.00]; // Yuqori notalar
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = gameState.audioContext.createOscillator();
                    const gain = gameState.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(gameState.audioContext.destination);

                    osc.frequency.value = freq;
                    osc.type = 'sine';

                    const volume = gameState.soundVolume / 100 * 0.1;
                    gain.gain.value = volume;
                    gain.gain.exponentialRampToValueAtTime(0.001, gameState.audioContext.currentTime + 0.25);

                    osc.start();
                    osc.stop(gameState.audioContext.currentTime + 0.25);
                }, i * 80);
            });
        };

        // Level up sound - celebration
        const playLevelUpSound = () => {
            if (!gameState.audioContext || !gameState.soundEnabled) return;

            const notes = [1046.50, 1318.51, 1567.98, 2093.00, 2637.02];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = gameState.audioContext.createOscillator();
                    const gain = gameState.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(gameState.audioContext.destination);

                    osc.frequency.value = freq;
                    osc.type = 'triangle';

                    const volume = gameState.soundVolume / 100 * 0.12;
                    gain.gain.value = volume;
                    gain.gain.exponentialRampToValueAtTime(0.001, gameState.audioContext.currentTime + 0.3);

                    osc.start();
                    osc.stop(gameState.audioContext.currentTime + 0.3);
                }, i * 70);
            });
        };

        // YANGI MUSIQA - Ingichka, baland melodiya
        const startBackgroundMusic = () => {
            if (!gameState.audioContext || !gameState.musicEnabled) return;

            stopBackgroundMusic();

            // Lofi-style ingichka melodiya
            const melody = [
                { notes: [1046.50, 1318.51, 1567.98], duration: 2000 }, // C-E-G yuqori
                { notes: [1174.66, 1396.91, 1760.00], duration: 2000 }, // D-F-A
                { notes: [1318.51, 1567.98, 1975.53], duration: 2000 }, // E-G-B
                { notes: [1396.91, 1760.00, 2093.00], duration: 2000 }  // F-A-C
            ];

            let melodyIndex = 0;
            let oscillators = [];
            const gainNode = gameState.audioContext.createGain();
            gainNode.connect(gameState.audioContext.destination);

            const updateVolume = () => {
                const volume = gameState.musicVolume / 100 * 0.02;
                gainNode.gain.value = volume;
            };
            updateVolume();

            const playMelody = () => {
                oscillators.forEach(osc => {
                    try { osc.stop(); osc.disconnect(); } catch (e) { }
                });
                oscillators = [];

                const current = melody[melodyIndex];
                current.notes.forEach((freq, idx) => {
                    const osc = gameState.audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    const oscGain = gameState.audioContext.createGain();
                    oscGain.gain.value = 0.15 + (idx * 0.1);

                    osc.connect(oscGain);
                    oscGain.connect(gainNode);

                    osc.start();
                    oscillators.push(osc);
                });

                melodyIndex = (melodyIndex + 1) % melody.length;
            };

            playMelody();
            const interval = setInterval(playMelody, 2000);
            gameState.backgroundMusic = { oscillators, interval, gainNode, updateVolume };
        };

        const stopBackgroundMusic = () => {
            if (gameState.backgroundMusic) {
                clearInterval(gameState.backgroundMusic.interval);
                gameState.backgroundMusic.oscillators.forEach(osc => {
                    try { osc.stop(); osc.disconnect(); } catch (e) { }
                });
                try { gameState.backgroundMusic.gainNode.disconnect(); } catch (e) { }
                gameState.backgroundMusic = null;
            }
        };

        const updateMusicVolume = () => {
            if (gameState.backgroundMusic && gameState.backgroundMusic.updateVolume) {
                gameState.backgroundMusic.updateVolume();
            }
        };

        // Game Initialization
        const initStage = (stage) => {
            const level = getCurrentLevel(stage);
            const size = getGridSize(level);
            const colorCount = getColorCount(level);
            const availableColors = GAME_COLORS.slice(0, colorCount);

            gameState.grid = createEmptyGrid(size);
            gameState.targetGrid = createTargetGrid(size, stage, level);
            gameState.moves = 0;
            gameState.completed = false;
            gameState.selectedColor = availableColors[0];
            render();
        };

        const handleCellClick = (row, col) => {
            if (gameState.completed) return;

            gameState.grid[row][col] = gameState.selectedColor;
            gameState.moves++;
            playColorSound(gameState.selectedColor);

            const isComplete = checkCompletion(gameState.grid, gameState.targetGrid);
            if (isComplete) {
                gameState.completed = true;
                const stageScore = calculateScore(gameState.moves, gameState.currentStage, gameState.targetGrid);
                gameState.score += stageScore;

                setTimeout(() => {
                    if (getStageInLevel(gameState.currentStage) === 5) {
                        playLevelUpSound();
                    } else {
                        playSuccessSound();
                    }
                }, 200);
            }

            render();
        };

        // Render
        const render = () => {
            document.body.setAttribute('data-theme', gameState.darkMode ? 'dark' : 'light');

            const app = document.getElementById('app');
            const level = getCurrentLevel(gameState.currentStage);
            const stageInLevel = getStageInLevel(gameState.currentStage);
            const size = gameState.grid.length;
            const cellSize = Math.min(35, 450 / size);
            const colorCount = getColorCount(level);
            const availableColors = GAME_COLORS.slice(0, colorCount);

            const bgGradient = gameState.darkMode
                ? 'from-gray-900 via-purple-900 to-gray-900'
                : 'from-indigo-600 via-purple-600 to-pink-600';

            app.innerHTML = `
                <div class="game-container bg-gradient-to-br ${bgGradient}">
                    <div class="max-w-7xl mx-auto">
                        <!-- Header -->
                        <div class="card p-6 mb-4">
                            <div class="flex items-center justify-between flex-wrap gap-4">
                                <div>
                                    <h1 class="text-3xl font-bold" style="color: var(--text-primary)">üé® –ü–∏–∫—Å–µ–ª—å–Ω—ã–π –ú–∞—Å—Ç–µ—Ä</h1>
                                    <p style="color: var(--text-secondary)">–≠—Ç–∞–ø ${gameState.currentStage}/${gameState.totalStages} | –£—Ä–æ–≤–µ–Ω—å ${level} (${stageInLevel}/5)</p>
                                </div>
                                <div class="flex gap-6">
                                    <div class="text-center">
                                        <p class="text-2xl font-bold text-purple-600">${level}</p>
                                        <p class="text-xs" style="color: var(--text-secondary)">–£—Ä–æ–≤–µ–Ω—å</p>
                                    </div>
                                    <div class="text-center">
                                        <p class="text-2xl font-bold text-yellow-500">${gameState.score}</p>
                                        <p class="text-xs" style="color: var(--text-secondary)">–û—á–∫–∏</p>
                                    </div>
                                    <div class="text-center">
                                        <p class="text-2xl font-bold text-blue-500">${gameState.moves}</p>
                                        <p class="text-xs" style="color: var(--text-secondary)">–•–æ–¥—ã</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Controls -->
                            <div class="flex flex-wrap gap-2 mt-4 justify-center items-center">
                                <button onclick="toggleSound()" class="px-4 py-2 rounded-lg font-medium text-sm ${gameState.soundEnabled ? 'bg-green-500 text-white' : 'bg-gray-300 text-gray-700'}">
                                    ${gameState.soundEnabled ? 'üîä –ó–≤—É–∫' : 'üîá –ó–≤—É–∫'}
                                </button>

                                <div class="flex items-center gap-2 px-3 py-2 bg-gray-100 rounded-lg">
                                    <span class="text-xs">üîâ</span>
                                    <input type="range" min="0" max="100" value="${gameState.soundVolume}"
                                           oninput="updateSoundVolume(this.value)" />
                                    <span class="text-xs font-bold">${gameState.soundVolume}%</span>
                                </div>

                                <button onclick="toggleMusic()" class="px-4 py-2 rounded-lg font-medium text-sm ${gameState.musicEnabled ? 'bg-blue-500 text-white' : 'bg-gray-300 text-gray-700'}">
                                    ${gameState.musicEnabled ? 'üéµ –ú—É–∑—ã–∫–∞' : 'üéµ –ú—É–∑—ã–∫–∞'}
                                </button>

                                <div class="flex items-center gap-2 px-3 py-2 bg-gray-100 rounded-lg">
                                    <span class="text-xs">üé∂</span>
                                    <input type="range" min="0" max="100" value="${gameState.musicVolume}"
                                           oninput="updateMusicVolumeSlider(this.value)" />
                                    <span class="text-xs font-bold">${gameState.musicVolume}%</span>
                                </div>

                                <button onclick="toggleDarkMode()" class="px-4 py-2 rounded-lg font-medium text-sm ${gameState.darkMode ? 'bg-yellow-500 text-gray-900' : 'bg-gray-800 text-white'}">
                                    ${gameState.darkMode ? '‚òÄÔ∏è –°–≤–µ—Ç–ª–∞—è' : 'üåô –¢—ë–º–Ω–∞—è'}
                                </button>
                            </div>

                            <!-- Progress -->
                            <div class="mt-4">
                                <div class="flex justify-between text-xs mb-1" style="color: var(--text-secondary)">
                                    <span>–ù–∞ —É—Ä–æ–≤–Ω–µ: ${stageInLevel}/5</span>
                                    <span>${Math.floor((gameState.currentStage / gameState.totalStages) * 100)}% –≤—ã–ø–æ–ª–Ω–µ–Ω–æ</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-3">
                                    <div class="bg-gradient-to-r from-green-400 to-blue-500 h-3 rounded-full" style="width: ${(gameState.currentStage / gameState.totalStages) * 100}%"></div>
                                </div>
                            </div>
                        </div>

                        <div class="grid lg:grid-cols-2 gap-4">
                            <!-- Target -->
                            <div class="card p-6">
                                <div class="flex items-center justify-between mb-4">
                                    <h2 class="text-xl font-bold" style="color: var(--text-primary)">üéØ –û–±—Ä–∞–∑–µ—Ü</h2>
                                    <button onclick="toggleTarget()" class="px-4 py-2 rounded-lg hover:opacity-80" style="background-color: var(--border-color); color: var(--text-primary)">
                                        ${gameState.showTarget ? '–°–∫—Ä—ã—Ç—å' : '–ü–æ–∫–∞–∑–∞—Ç—å'}
                                    </button>
                                </div>
                                ${gameState.showTarget ? `
                                    <div class="flex justify-center">
                                        <div class="grid-container" style="grid-template-columns: repeat(${size}, ${cellSize}px)">
                                            ${gameState.targetGrid.map((row, i) =>
                row.map((color, j) => `
                                                    <div style="width: ${cellSize}px; height: ${cellSize}px; background-color: ${color};" class="rounded-sm border border-gray-400"></div>
                                                `).join('')
            ).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>

                            <!-- Player Grid -->
                            <div class="card p-6">
                                <h2 class="text-xl font-bold mb-4" style="color: var(--text-primary)">üé® –í–∞—à–∞ —Ä–∞–±–æ—Ç–∞</h2>
                                <div class="flex justify-center mb-4">
                                    <div class="grid-container" style="grid-template-columns: repeat(${size}, ${cellSize}px)">
                                        ${gameState.grid.map((row, i) =>
                row.map((color, j) => `
                                                <div onclick="handleCellClick(${i}, ${j})" style="width: ${cellSize}px; height: ${cellSize}px; background-color: ${color};" class="cell"></div>
                                            `).join('')
            ).join('')}
                                    </div>
                                </div>

                                <!-- Colors -->
                                <div class="border-t pt-4" style="border-color: var(--border-color)">
                                    <p class="text-sm font-medium mb-2" style="color: var(--text-primary)">–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç:</p>
                                    <div class="flex flex-wrap gap-2 justify-center">
                                        <button onclick="selectColor('${WHITE_COLOR}')" class="w-10 h-10 rounded-lg border-4 ${gameState.selectedColor === WHITE_COLOR ? 'border-blue-500 scale-110' : 'border-gray-300'}" style="background-color: ${WHITE_COLOR}"></button>
                                        ${availableColors.map(color => `
                                            <button onclick="selectColor('${color}')" class="w-10 h-10 rounded-lg border-4 ${gameState.selectedColor === color ? 'border-blue-500 scale-110' : 'border-gray-300'}" style="background-color: ${color}"></button>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="card p-6 mt-4">
                            <div class="flex justify-center gap-4">
                                <button onclick="resetStage()" class="px-6 py-3 bg-red-500 text-white rounded-xl hover:bg-red-600 font-medium">
                                    ‚Üª –°–±—Ä–æ—Å–∏—Ç—å
                                </button>
                                ${gameState.completed ? `
                                    <button onclick="nextStage()" class="px-6 py-3 bg-green-500 text-white rounded-xl hover:bg-green-600 font-medium animate-pulse-custom">
                                        ${gameState.currentStage < gameState.totalStages ? '–°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø ‚Üí' : '–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ üîÑ'}
                                    </button>
                                ` : ''}
                            </div>
                        </div>

                        ${gameState.completed ? `
                            <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div class="bg-white rounded-3xl p-8 max-w-md text-center">
                                    <div class="text-6xl mb-4">${stageInLevel === 5 ? 'üéä' : 'üéâ'}</div>
                                    <h2 class="text-3xl font-bold mb-2 text-gray-800">${stageInLevel === 5 ? `–£—Ä–æ–≤–µ–Ω—å ${level} –ø—Ä–æ–π–¥–µ–Ω!` : '–û—Ç–ª–∏—á–Ω–æ!'}</h2>
                                    <p class="text-xl text-gray-600 mb-4">–≠—Ç–∞–ø ${gameState.currentStage}/${gameState.totalStages}</p>
                                    <p class="text-2xl font-bold text-green-600 mb-4">–û—á–∫–∏: ${gameState.score}</p>
                                    ${stageInLevel === 5 ? '<p class="text-purple-600 font-bold mb-4">‚≠ê –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–µ–µ! ‚≠ê</p>' : ''}
                                    <button onclick="nextStage()" class="w-full py-4 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-xl font-bold text-lg">
                                        ${gameState.currentStage < gameState.totalStages ? '–°–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø ‚Üí' : '–ò–≥—Ä–∞—Ç—å –∑–∞–Ω–æ–≤–æ üîÑ'}
                                    </button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        };

        // Global functions
        window.handleCellClick = handleCellClick;
        window.selectColor = (color) => {
            gameState.selectedColor = color;
            render();
        };
        window.toggleTarget = () => {
            gameState.showTarget = !gameState.showTarget;
            render();
        };
        window.toggleSound = () => {
            gameState.soundEnabled = !gameState.soundEnabled;
            render();
        };
        window.toggleMusic = () => {
            gameState.musicEnabled = !gameState.musicEnabled;
            if (!gameState.musicEnabled) {
                stopBackgroundMusic();
            } else if (gameState.audioContext) {
                startBackgroundMusic();
            }
            render();
        };
        window.toggleDarkMode = () => {
            gameState.darkMode = !gameState.darkMode;
            render();
        };
        window.updateSoundVolume = (value) => {
            gameState.soundVolume = parseInt(value);
            render();
        };
        window.updateMusicVolumeSlider = (value) => {
            gameState.musicVolume = parseInt(value);
            updateMusicVolume();
            render();
        };
        window.resetStage = () => {
            initStage(gameState.currentStage);
        };
        window.nextStage = () => {
            if (gameState.currentStage < gameState.totalStages) {
                gameState.currentStage++;
            } else {
                gameState.currentStage = 1;
                gameState.score = 0;
            }
            initStage(gameState.currentStage);
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initAudio();
            initStage(1);
            startBackgroundMusic();
        });

        // Start audio on first click
        document.addEventListener('click', () => {
            if (gameState.audioContext && gameState.audioContext.state === 'suspended') {
                gameState.audioContext.resume();
            }
        }, { once: true });
    </script>

    <!-- Yandex Games SDK -->
    <script src="https://yandex.ru/games/sdk/v2"></script>

    <script>
        let ysdk = null;

        // YANDEX SDK INIT
        async function initSDK() {
            try {
                ysdk = await YaGames.init();
                console.log("Yandex SDK Loaded ‚úî");

                initAds();
            } catch (e) {
                console.error("SDK init error:", e);
            }
        }

        // ADS INIT
        function initAds() {
            if (ysdk && ysdk.adv) {
                ysdk.adv.getFullscreenAdv();
                ysdk.adv.getRewardedVideoAdv();
            }
        }

        // FULLSCREEN ADS
        async function showFullscreenAd() {
            try {
                if (ysdk && ysdk.adv) {
                    await ysdk.adv.showFullscreenAdv({
                        callbacks: {
                            onClose: () => console.log("Fullscreen closed"),
                            onError: (err) => console.error("Fullscreen error:", err)
                        }
                    });
                }
            } catch (e) {
                console.error(e);
            }
        }

        // REWARDED VIDEO ADS
        async function showRewardedAd(onReward) {
            try {
                if (ysdk && ysdk.adv) {
                    await ysdk.adv.showRewardedVideo({
                        callbacks: {
                            onRewarded: () => {
                                console.log("Reward given!");
                                if (onReward) onReward();
                            },
                            onError: (err) => console.error("Reward error:", err)
                        }
                    });
                }
            } catch (err) {
                console.error(err);
            }
        }

        // Yandex SDK yuklanganda ishga tushadi
        window.addEventListener('load', () => {
            if (typeof YaGames !== 'undefined') {
                initSDK();
            }
        });

        // Next stage funksiyasini yangilaymiz
        const originalNextStage = window.nextStage;
        window.nextStage = () => {
            // Har 3-bosqichda reklama ko'rsatish
            if (gameState.currentStage % 3 === 0) {
                showFullscreenAd();
            }

            // Asl funksiyani chaqiramiz
            originalNextStage();
        };
    </script>
</body>
</html>
